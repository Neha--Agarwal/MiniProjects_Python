from __future__ import print_function
import sys
"""A rat starts from source and has to reach destination. The rat can move only in two directions: forward and down.
In the maze matrix, 0 means the block is dead end and 1 means the block can be used in the path from source to destination. Note that this is a simple version of the typical Maze problem.Following is an example maze.

 Gray blocks are dead ends (value = 0). 


Following is binary matrix representation of the above maze.

                {1, 0, 0, 0}
                {1, 1, 0, 1}
                {0, 1, 0, 0}
                {1, 1, 1, 1}

Following is the solution matrix (output of program) for the above input matrix.

                {1, 0, 0, 0}
                {1, 1, 0, 0}
                {0, 1, 0, 0}
                {0, 1, 1, 1}
 All enteries in solution path are marked as 1."""
"""print(sys.version)"""
N=4

#A utility function to print solution matrix sol[N][N]
def printSolution( sol):    
    for i in range(N):    
        for j in range(N):
           print(sol[i][j], end=" ")
        print("\n") 

#A utility function to check if x,y is valid index for N*N maze
def isSafe( maze,  x,  y):
    # if (x,y outside maze) return False    
    if(x >= 0 and x < N and y >= 0 and y < N and maze[x][y] == 1):
        return True 
    return False

"""This function solves the Maze problem using Backtracking.  It mainly uses
solveMazeUtil() to solve the problem. It returns False if no path is possible,
otherwise return True and prs the path in the form of 1s. Please note that
there may be more than one solutions, this function prs one of the feasible
solutions."""
def solveMaze( maze):
    sol = [[ 0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0],[0, 0, 0, 0]]     
    if(solveMazeUtil(maze, 0, 0, sol) == False):    
        print("Solution doesn't exist")
        return False
    printSolution(sol)
    return True

#A recursive utility function to solve Maze problem
def solveMazeUtil( maze,  x,  y,  sol):    
    #if (x,y is goal) return True
    if(x == N-1 and y == N-1):    
        sol[x][y] = 1
        return True 
    #Check if maze is valid
    if(isSafe(maze, x, y) == True):    
        #mark x,y as part of solution path
        sol[x][y] = 1 
        #Move forward in x direction
        if (solveMazeUtil(maze, x+1, y, sol) == True):
            return True 
        #If moving in x direction doesn't give solution then move down in y direction
        if (solveMazeUtil(maze, x, y+1, sol) == True):
            return True 
        #If none of the above movements work then BACKTRACK: unmark x,y as part of solution path
        sol[x][y] = 0
        return False 
    return False 

#driver program to test above function
maze  =  [[ 1, 0, 0, 0],[1, 1, 0, 1],[0, 1, 0, 0],[1, 1, 1, 1]]
solveMaze(maze)
